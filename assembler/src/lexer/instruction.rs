use phf::phf_map;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Instruction {
    PSHA,
    PSHX,
    PSHY,
    PSHC,
    PULA,
    PULX,
    PULY,
    PULC,
    TFR,
    BSR,
    BRA,
    BMI,
    BPL,
    BEQ,
    BNE,
    BVS,
    BVC,
    BCS,
    BCC,
    STX,
    STY,
    STSP,
    JMP,
    JSR,
    CLR,
    NEG,
    INC,
    DEC,
    TST,
    RTS,
    RTI,
    LDX,
    LDY,
    LDSP,
    SBCA,
    SUBA,
    ADCA,
    ADDA,
    CMPA,
    BITA,
    ANDA,
    NOP,
    LDA,
    ANDCC,
    STA,
    ORCC,
    CLRA,
    NEGA,
    INCA,
    DECA,
    TSTA,
    COMA,
    BHI,
    COM,
    ORA,
    LSLA,
    BLS,
    LSL,
    EORA,
    LSRA,
    BGT,
    LSR,
    CMPX,
    LEAX,
    ROLA,
    BGE,
    ROL,
    CMPY,
    LEAY,
    RORA,
    BLE,
    ROR,
    CMPSP,
    LEASP,
    ASRA,
    BLT,
    ASR,
    EXG,
}

static INSTRUCTIONS: phf::Map<&'static str, Instruction> = phf_map! {
    "PSHA" => Instruction::PSHA,
    "PSHX" => Instruction::PSHX,
    "PSHY" => Instruction::PSHY,
    "PSHC" => Instruction::PSHC,
    "PULA" => Instruction::PULA,
    "PULX" => Instruction::PULX,
    "PULY" => Instruction::PULY,
    "PULC" => Instruction::PULC,
    "TFR" => Instruction::TFR,
    "BSR" => Instruction::BSR,
    "BRA" => Instruction::BRA,
    "BMI" => Instruction::BMI,
    "BPL" => Instruction::BPL,
    "BEQ" => Instruction::BEQ,
    "BNE" => Instruction::BNE,
    "BVS" => Instruction::BVS,
    "BVC" => Instruction::BVC,
    "BCS" => Instruction::BCS,
    "BCC" => Instruction::BCC,
    "STX" => Instruction::STX,
    "STY" => Instruction::STY,
    "STSP" => Instruction::STSP,
    "JMP" => Instruction::JMP,
    "JSR" => Instruction::JSR,
    "CLR" => Instruction::CLR,
    "NEG" => Instruction::NEG,
    "INC" => Instruction::INC,
    "DEC" => Instruction::DEC,
    "TST" => Instruction::TST,
    "RTS" => Instruction::RTS,
    "RTI" => Instruction::RTI,
    "LDX" => Instruction::LDX,
    "LDY" => Instruction::LDY,
    "LDSP" => Instruction::LDSP,
    "SBCA" => Instruction::SBCA,
    "SUBA" => Instruction::SUBA,
    "ADCA" => Instruction::ADCA,
    "ADDA" => Instruction::ADDA,
    "CMPA" => Instruction::CMPA,
    "BITA" => Instruction::BITA,
    "ANDA" => Instruction::ANDA,
    "NOP" => Instruction::NOP,
    "LDA" => Instruction::LDA,
    "ANDCC" => Instruction::ANDCC,
    "STA" => Instruction::STA,
    "ORCC" => Instruction::ORCC,
    "CLRA" => Instruction::CLRA,
    "NEGA" => Instruction::NEGA,
    "INCA" => Instruction::INCA,
    "DECA" => Instruction::DECA,
    "TSTA" => Instruction::TSTA,
    "COMA" => Instruction::COMA,
    "BHI" => Instruction::BHI,
    "COM" => Instruction::COM,
    "ORA" => Instruction::ORA,
    "LSLA" => Instruction::LSLA,
    "BLS" => Instruction::BLS,
    "LSL" => Instruction::LSL,
    "EORA" => Instruction::EORA,
    "LSRA" => Instruction::LSRA,
    "BGT" => Instruction::BGT,
    "LSR" => Instruction::LSR,
    "CMPX" => Instruction::CMPX,
    "LEAX" => Instruction::LEAX,
    "ROLA" => Instruction::ROLA,
    "BGE" => Instruction::BGE,
    "ROL" => Instruction::ROL,
    "CMPY" => Instruction::CMPY,
    "LEAY" => Instruction::LEAY,
    "RORA" => Instruction::RORA,
    "BLE" => Instruction::BLE,
    "ROR" => Instruction::ROR,
    "CMPSP" => Instruction::CMPSP,
    "LEASP" => Instruction::LEASP,
    "ASRA" => Instruction::ASRA,
    "BLT" => Instruction::BLT,
    "ASR" => Instruction::ASR,
    "EXG" => Instruction::EXG,
};

pub fn parse_instruction(ins: &str) -> Option<Instruction> {
    INSTRUCTIONS.get(ins.to_uppercase().as_str()).cloned()
}
